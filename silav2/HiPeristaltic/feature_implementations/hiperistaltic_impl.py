# Generated by sila2.code_generator; sila2.__version__: 0.12.2
from __future__ import annotations
from .HiPeristalticInterface import HiPeristalticInterface
from datetime import timedelta
from time import sleep
from typing import TYPE_CHECKING

from sila2.server import MetadataDict, ObservableCommandInstance, ObservableCommandInstanceWithIntermediateResponses

from ..generated.hiperistaltic import (
    HiPeristalticBase,
    ResumePump_IntermediateResponses,
    ResumePump_Responses,
    SetPumpCalibration_Responses,
    StartPump_IntermediateResponses,
    StartPump_Responses,
    StartPumpCalibration_IntermediateResponses,
    StartPumpCalibration_Responses,
    StartPumpContinuous_IntermediateResponses,
    StartPumpContinuous_Responses,
    StopPump_Responses,
    FlowRateOutOfRange,
    TargetVolumeOutOfRange,
    RPMOutOfRange,
    # PumpIndexOutOfRange, #one can add other exceptions defined in XML to here
)

if TYPE_CHECKING:
    from ..server import Server


class HiPeristalticImpl(HiPeristalticBase):

    driver: HiPeristalticInterface = None

    def __init__(self, parent_server: Server) -> None:
        super().__init__(parent_server=parent_server)
        self.driver = HiPeristalticInterface()
        self.driver.load_config()
        self.driver.connect()
        # Default lifetime of observable command instances. Possible values:
        # None: Command instance is valid and stored in memory until server shutdown
        # datetime.timedelta: Command instance is deleted after this duration, can be increased during command runtime
        self.StartPump_default_lifetime_of_execution = timedelta(minutes=30)
        self.StartPumpContinuous_default_lifetime_of_execution = timedelta(minutes=30)
        self.StopPump_default_lifetime_of_execution = timedelta(minutes=30)
        self.ResumePump_default_lifetime_of_execution = timedelta(minutes=30)
        self.StartPumpCalibration_default_lifetime_of_execution = timedelta(minutes=30)

    def SetPumpCalibration(
        self, PumpIndex: int, CalibrationParameter: float, *, metadata: MetadataDict
    ) -> SetPumpCalibration_Responses:
        PumpIndex = PumpIndex - 1
        if self.driver.pumps[PumpIndex].get_running():
            # If the pump is already running then stop it first
            self.driver.pumps[PumpIndex].pump_stop()
            #then wait for the stopping to be registered by sila
            sleep(1.5)
        self.driver.pumps[PumpIndex].uL_per_rev = CalibrationParameter
        self.driver.save_config()
        return SetPumpCalibration_Responses(True)

    def StartPump(
        self,
        PumpIndex: int,
        FlowRate: float,
        TargetVolume: float,
        PumpDirection: str,
        *,
        metadata: MetadataDict,
        instance: ObservableCommandInstanceWithIntermediateResponses[StartPump_IntermediateResponses],
    ) -> StartPump_Responses:
        # set execution status from `waiting` to `running`
        instance.begin_execution()
        PumpIndex = PumpIndex - 1
        if self.driver.pumps[PumpIndex].get_running():
            # If the pump is already running then stop it first
            self.driver.pumps[PumpIndex].pump_stop()
            #then wait for the stopping to be registered by sila
            sleep(1.5)
        if FlowRate > self.driver.pumps[PumpIndex].get_max_flow_rate_uLpersec():
            raise FlowRateOutOfRange
        if FlowRate < self.driver.pumps[PumpIndex].get_min_flow_rate_uLpersec():
            raise FlowRateOutOfRange
        if TargetVolume > self.driver.pumps[PumpIndex].get_max_volume_uL():
            raise TargetVolumeOutOfRange
        if TargetVolume < self.driver.pumps[PumpIndex].get_min_volume_uL():
            raise TargetVolumeOutOfRange
        # Start the pump
        self.driver.pumps[PumpIndex].pump_volume(flow_rate_uLpersec=FlowRate, target_volume_uL=TargetVolume, direction=PumpDirection,blocking=False)
        total_time_s = TargetVolume / FlowRate
        instance.lifetime_of_execution = timedelta(seconds=total_time_s + 300)
        elapsed_time_s = 0
        while self.driver.pumps[PumpIndex].get_running():
            sleep(0.33)
            elapsed_time_s += 0.33
            remaining_time_s = total_time_s - elapsed_time_s
            if remaining_time_s < 0:
                remaining_time_s = 0
            instance.estimated_remaining_time = timedelta(seconds=remaining_time_s)
            progress = elapsed_time_s / total_time_s
            if progress > 1:
                progress = 1
            instance.progress = progress
            instance.send_intermediate_response(StartPump_IntermediateResponses(elapsed_time_s*FlowRate)) #amount of liquid pumped in uL
        
        remaining_vol_uL = self.driver.pumps[PumpIndex].get_remaining_volume_uL()
        pumped_vol_uL = TargetVolume - remaining_vol_uL
        return StartPump_Responses(pumped_vol_uL)

    def StartPumpContinuous(
        self,
        PumpIndex: int,
        FlowRate: float,
        PumpDirection: str,
        *,
        metadata: MetadataDict,
        instance: ObservableCommandInstanceWithIntermediateResponses[StartPumpContinuous_IntermediateResponses],
    ) -> StartPumpContinuous_Responses:
        # set execution status from `waiting` to `running`
        instance.begin_execution()
        PumpIndex = PumpIndex - 1
        if self.driver.pumps[PumpIndex].get_running():
            # If the pump is already running then stop it first
            self.driver.pumps[PumpIndex].pump_stop()
            #then wait for the stopping to be registered by sila
            sleep(1.5)
        if FlowRate > self.driver.pumps[PumpIndex].get_max_flow_rate_uLpersec():
            raise FlowRateOutOfRange
        if FlowRate < self.driver.pumps[PumpIndex].get_min_flow_rate_uLpersec():
            raise FlowRateOutOfRange
        # Start the pump
        self.driver.pumps[PumpIndex].pump_continuous(flow_rate_uLpersec=FlowRate, direction=PumpDirection)
        instance.lifetime_of_execution = timedelta(days=1)
        elapsed_time_s = 0
        while self.driver.pumps[PumpIndex].get_running():
            sleep(0.33)
            elapsed_time_s += 0.33
            instance.send_intermediate_response(StartPump_IntermediateResponses(elapsed_time_s*FlowRate)) #amount of liquid pumped in uL
        
        pumped_vol_uL = elapsed_time_s*FlowRate
        return StartPump_Responses(pumped_vol_uL)

    def StopPump(
        self, PumpIndex: int, *, metadata: MetadataDict, instance: ObservableCommandInstance
    ) -> StopPump_Responses:
        # set execution status from `waiting` to `running`
        instance.begin_execution()
        PumpIndex = PumpIndex - 1
        result = self.driver.pumps[PumpIndex].pump_stop()
        return StopPump_Responses(result)

    def ResumePump(
        self,
        PumpIndex: int,
        *,
        metadata: MetadataDict,
        instance: ObservableCommandInstanceWithIntermediateResponses[ResumePump_IntermediateResponses],
    ) -> ResumePump_Responses:
        # set execution status from `waiting` to `running`
        instance.begin_execution()
        PumpIndex = PumpIndex - 1
        if self.driver.pumps[PumpIndex].get_running():
            return ResumePump_Responses(0)
        
        # Start the pump
        target_volume_uL = self.driver.pumps[PumpIndex].get_target_volume_uL()
        flow_rate_uLpersec = self.driver.pumps[PumpIndex].get_flow_rate_uLpersec()
        self.driver.pumps[PumpIndex].pump_resume()
        total_time_s = target_volume_uL / flow_rate_uLpersec
        instance.lifetime_of_execution = timedelta(seconds=total_time_s + 300)
        elapsed_time_s = total_time_s - self.driver.pumps[PumpIndex].get_remaining_time().total_seconds()
        while self.driver.pumps[PumpIndex].get_running():
            remaining_time_s = total_time_s - elapsed_time_s
            if remaining_time_s < 0:
                remaining_time_s = 0
            instance.estimated_remaining_time = timedelta(seconds=remaining_time_s)
            progress = elapsed_time_s / total_time_s
            if progress > 1:
                progress = 1
            instance.progress = progress
            instance.send_intermediate_response(ResumePump_IntermediateResponses(elapsed_time_s*flow_rate_uLpersec)) #amount of liquid pumped in uL
            sleep(0.33)
            elapsed_time_s += 0.33
        
        remaining_vol_uL = self.driver.pumps[PumpIndex].get_remaining_volume_uL()
        pumped_vol_uL = target_volume_uL - remaining_vol_uL
        return ResumePump_Responses(pumped_vol_uL)

    def StartPumpCalibration(
        self,
        PumpIndex: int,
        RPM: float,
        TargetRevolutions: float,
        PumpDirection: str,
        *,
        metadata: MetadataDict,
        instance: ObservableCommandInstanceWithIntermediateResponses[StartPumpCalibration_IntermediateResponses],
    ) -> StartPumpCalibration_Responses:
        # set execution status from `waiting` to `running`
        instance.begin_execution()
        PumpIndex = PumpIndex - 1
        if self.driver.pumps[PumpIndex].get_running():
            # If the pump is already running then stop it first
            self.driver.pumps[PumpIndex].pump_stop()
            #then wait for the stopping to be registered by sila
            sleep(1.5)
        if RPM > self.driver.pumps[PumpIndex].get_max_rpm():
            raise RPMOutOfRange
        if RPM < self.driver.pumps[PumpIndex].get_min_rpm():
            raise RPMOutOfRange
        temp_vol_uL = TargetRevolutions * self.driver.pumps[PumpIndex].uL_per_rev
        total_time_s = (TargetRevolutions / RPM) * 60
        temp_flow_rate_uLpersec = temp_vol_uL / total_time_s
        elapsed_time_s = 0
        instance.lifetime_of_execution = timedelta(seconds=total_time_s + 300)
        self.driver.pumps[PumpIndex].pump_volume(flow_rate_uLpersec=temp_flow_rate_uLpersec, target_volume_uL=temp_vol_uL, direction=PumpDirection,blocking=False)
        while self.driver.pumps[PumpIndex].get_running():
            remaining_time_s = total_time_s - elapsed_time_s
            if remaining_time_s < 0:
                remaining_time_s = 0
            instance.estimated_remaining_time = timedelta(seconds=remaining_time_s)
            progress = elapsed_time_s / total_time_s
            if progress > 1:
                progress = 1
            instance.progress = progress
            instance.send_intermediate_response(StartPumpCalibration_IntermediateResponses((elapsed_time_s/60) * RPM))
            sleep(0.33)
            elapsed_time_s += 0.33

        return StartPumpCalibration_Responses(True)
